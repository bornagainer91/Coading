#include <iostream>
#include <algorithm>
#include <climits>

#define MAX_T 100

using namespace std;

/*
===============================================================
[ 문제 설명 Summary ]

좌표선 위에 여러 개의 알파벳이 주어짐.
각 알파벳은 위치값을 하나씩 가지고 있으며, 종류는 'S' 혹은 'N'.

우리는 x의 범위 a ~ b 사이의 모든 정수 위치에 대해 다음을 판단해야 함.

---------------------------------------------------------------
1) d1 = 해당 x에서 가장 가까운 'S'까지의 거리
2) d2 = 해당 x에서 가장 가까운 'N'까지의 거리

★ 특별한 위치 조건:
    d1 <= d2 이면, x는 "특별한 위치"로 인정됨.

---------------------------------------------------------------
목표:
a ~ b 전체 범위 중 특별한 위치의 개수를 출력하기.

---------------------------------------------------------------
입력:
T     : 알파벳 총 개수
a, b  : 검사할 x 구간 (a <= x <= b)
이후 T개의 줄:
    알파벳(S/N) + 해당 알파벳의 위치값

---------------------------------------------------------------
해결 전략 요약:

1. 입력 시 S 위치들만 s[] 배열에 저장,
            N 위치들만 n[] 배열에 저장한다.
   → S, N을 섞어서 저장하면 거리 계산이 복잡해지므로,
     입력 단계에서 미리 분리해두는 것이 핵심.

2. x = a ~ b 까지 모든 좌표를 하나씩 확인한다.
   - S 배열을 돌며 최소 거리(distance_s) 계산
   - N 배열을 돌며 최소 거리(distance_n) 계산

3. distance_s <= distance_n 이면 특별한 위치 → 카운트 증가

4. 최종적으로 특별한 위치의 총 개수 출력

===============================================================
*/

int t, a, b;           // t: 알파벳(S/N) 개수, a~b: 검사 범위

int s[MAX_T];          // S 좌표들을 저장하는 배열
int n[MAX_T];          // N 좌표들을 저장하는 배열
int cnt_s = 0;         // S 개수
int cnt_n = 0;         // N 개수

int main()
{
    // --- 입력 수신 ---
    cin >> t >> a >> b;

    /*
        입력을 받으면서 S와 N을 각각 분리하여 저장.
        이렇게 해두면 거리 계산 시 매우 직관적으로 처리할 수 있음.
    */
    for (int i = 0; i < t; i++)
    {
        char alpabet {};
        int pos {};

        cin >> alpabet >> pos;

        if (alpabet == "S"[0]) // S면 s배열에 저장
        {
            s[cnt_s++] = pos;
        }
        else                   // N이면 n배열에 저장
        {
            n[cnt_n++] = pos;
        }
    }

    int ans = 0;   // 특별한 위치 개수를 저장할 변수

    /*
        x = a ~ b 까지 모든 정수 위치를 검사.
        각 x에서 S와 N까지의 최소 거리를 비교해 특별한 위치인지 판정.
    */
    for (int x = a; x <= b; x++)
    {
        int distance_s = INT_MAX;   // x에서 가장 가까운 S까지의 거리
        int distance_n = INT_MAX;   // x에서 가장 가까운 N까지의 거리

        // --- S 최소거리 계산 ---
        /*
            현재 x에서 모든 S 좌표와의 거리 |s[j] - x| 중
            가장 작은 값을 distance_s 에 저장.
        */
        for (int j = 0; j < cnt_s; j++)
        {
            distance_s = min(distance_s, abs(s[j] - x));
        }

        // --- N 최소거리 계산 ---
        /*
            현재 x에서 모든 N 좌표와의 거리 |n[j] - x| 중
            가장 작은 값을 distance_n 에 저장.
        */
        for (int j = 0; j < cnt_n; j++)
        {
            distance_n = min(distance_n, abs(n[j] - x));
        }

        /*
            특별한 위치 판정:
            - S가 더 가깝거나 (distance_s < distance_n)
            - S와 N까지의 거리가 같으면(distance_s == distance_n)

            즉, distance_s <= distance_n 이면 특별한 위치.
        */
        if (distance_s <= distance_n)
        {
            ans++;     // 특별한 위치 하나 증가
        }
    }

    // --- 결과 출력 ---
    cout << ans;

    return 0;
}